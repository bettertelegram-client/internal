#include <vendor.h>
#include <entry.hpp>
#include <nlohmann/json.hpp>

#include <api/licence.hpp>
#include <api/rtti.hpp>

#ifdef _WIN

#ifdef _WIN64
#include <locale>
#include <codecvt>
#include <ShlObj.h>
#pragma comment (lib, "shlwapi.lib")
//#pragma comment (lib, "libs\\linker\\gcrypt_w64.lib")
#pragma comment (lib, "libs\\linker\\libgcrypt.lib")
#pragma comment (lib, "libs\\linker\\libgpg-error.lib")
#else
//#pragma comment (lib, "libs\\linker\\gcrypt_w32.lib")
#pragma comment (lib, "libs\\linker\\static_gcrypt_w32.lib")
#endif

/*

	[DONE]: make a directory version system, when the injector downloads the DLL, it should get the version of Telegram & send it to the server so
	      that the DLL which is returned is the latest version specific to that specific telegram version (incase we update to new telegram versions,
		  but some people still havent updated their telegram clients to the newest versions supported)

    [DONE] when user logs in, the server will return the session key which was b64 ( rc4 encoded ), where the key is every 4th character of the licence key
    [DONE] the encoded session key is then stored inside the BT folder with the name rdfs.bin
	[DONE] once the DLL is injected, in the auto_updater we first checked if we are loaded by the telegram process
	   - GetFileVersion of the current EXE path & check if the version is the same as 

	   %d = *reinterpret_cast <uint32_t*> (single <telegram::memory::c_memory_util>()->search(enerate_signature_ex("", "", 2, false)))

	   - this is a good check since this the hook will crash OR it wont return the same info if the DLL is loaded by any other process

	[DONE] then read & decode the session key from rdfs.bin with the BT licence from HKCU Software BetterTelegram "licence_key" value
	[DONE] now send a GET request with the b64-encoded rdfs.bin value in the parameter to /licence/b64(rdfs.bin)
	[DONE] if the session key is valid, the response will contain the 1, 2, 3, 4, 5 values json object which will be encrypted with B64 & AES256 using the session key
	[DONE] once the data strings are retrieved, only then should the DLL functionality be unlocked by setting the value for a global variable from within the updater
	   (but at the same time, that same global variable should be set using dummy conditions scattered around the program to defer the tracing)
	[DONE] after the first GET request, when all operations are performed, all other requests are POST requests sent to /licence/b64(rdfs.bin) and the POST data
	   containing the session-key encoded {"dv":"dll_version","tv":"tg_version"}
	[DONE] the response to the POST request be {"bt_vers":"latest supported BT version","require_unhook":"yes","new_func_sigs":"yes"}
    [DONE] check if the licence is active (there is >= 1 day(s) remaining on it), if its not then make sure that OTR will be disabled for the duration of execution
    [DONE] do the RTTI, place them program-wide & along with protection_instance.decrypt_string()
    [DONE] try to add a TOTP to the server-side check, if the client side time-based seed doesnt match the one generated by the server then crash
    [DONE] add ssl-pinning, so if the server certificate returned by the GET/POST
       response, calculate its CRC32, if its not matched on the client-side then crash
    [DONE] migrate the new webapp landing page text/buttons edits onto the current version of it & publish
    [DONE] Test the app all together in real time Group/Solo Chats & just make sure everything is working smoothly as we expect
    [DONE] add a loading bar to display DLL download progress in the GUI, PLUS make sure that the GUI can send a request to check if a new dll is available, if so only
       then subsequently download it, but if its the same version, no reason to download it again

*/

#define min(a, b) ((a) < (b) ? (a) : (b))
static unsigned long __stdcall auto_updater(void* data) {

    WSADATA wsa_data;
    if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0) __debugbreak();

    wchar_t exe_path[260] = { 0 };
    GetModuleFileNameW(0, exe_path, 260);

    DWORD ver_handle = 0;
    DWORD ver_size = GetFileVersionInfoSizeW(exe_path, &ver_handle);
    std::vector<char> ver_data(ver_size);

    if (!GetFileVersionInfoW(exe_path, ver_handle, ver_size, ver_data.data()))
        __debugbreak();

    UINT len = 0;
    VS_FIXEDFILEINFO* file_info = 0;
    if (!VerQueryValueW(ver_data.data(), L"\\", (LPVOID*)&file_info, &len))
        __debugbreak();
    
    uint32_t real_tg_version = *reinterpret_cast<uint32_t*>(
        single<telegram::memory::c_memory_util>()->search(
            generate_signature_ex("", "", 2, false)));

    if (!real_tg_version) __debugbreak();

    WORD file_tg_major = HIWORD(file_info->dwFileVersionMS);
    WORD file_tg_minor = LOWORD(file_info->dwFileVersionMS);
    WORD file_tg_build = HIWORD(file_info->dwFileVersionLS);
    WORD file_tg_rel   = LOWORD(file_info->dwFileVersionLS);

    bool match = true;
    std::string r = std::to_string(real_tg_version);

    size_t pos_major = r.find(std::to_string(file_tg_major));
    if (pos_major == std::string::npos) match = false;

    size_t pos_minor = r.find(std::to_string(file_tg_minor), pos_major + std::to_string(file_tg_major).length());
    if (pos_minor == std::string::npos) match = false;

    size_t pos_build = r.find(std::to_string(file_tg_build), pos_minor + std::to_string(file_tg_minor).length());
    if (pos_build == std::string::npos) match = false;

    if (!match) __debugbreak();

    HKEY hKey;
    if (RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\BetterTelegram", 0, KEY_READ, &hKey) != ERROR_SUCCESS) __debugbreak();

    char licence[32] = { 0 };
    DWORD size = sizeof(licence);
    if (RegQueryValueExA(hKey, "licence", 0, 0, (LPBYTE)licence, &size) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        __debugbreak();
    }
    RegCloseKey(hKey);

    wchar_t appdata[260] = { 0 }, path[260] = { 0 };
    SHGetFolderPathW(0, CSIDL_APPDATA, 0, 0, appdata);
    swprintf_s(path, 260, L"%s\\BetterTelegram\\rdfs.bin", appdata);

    std::ifstream file(path, std::ios::binary);
    if (!file) __debugbreak();

    std::vector<BYTE> bin_data((std::istreambuf_iterator<char>(file)), {});
    file.close();

    std::string session_key = single<licence::protection>()->rc4_decode(std::string(bin_data.begin(), bin_data.end()), licence);
    std::string licence_str(licence, strlen(licence));

    nlohmann::json response = nullptr;
    while (response == nullptr || response.empty() || response.is_null()) {
        response = single<licence::protection>()->send_get_request("https://bettertelegram.org/licence/" + licence_str, session_key);
        Sleep(1000);
    }
   
    // we just wont return a valid response if the TOTP doesnt match (3 times) the one on the server & automatically ban the licence on the server (no tolerance policy)
    if (response.contains("1") && response.contains("2") && response.contains("3") && response.contains("4") && response.contains("5")) {

        std::string session_key_stored = session_key;
        for (int poll_num = 0, fail_count = 0;; ++poll_num) {

            if (poll_num == 0) {

                c_entry entry;
                entry.init_common();
                entry.init_buttons();

                auto storage = single <crypto::otr::c_storage_manager>();
                auto paths = storage->get_key_path(telegram::peer::get_own_id().value);
                storage->setup_keys(storage->get_state(), paths.first, paths.second);
                
                licence::protection::init_instance(response, session_key);
                bool licence_not_expired = response.at("5").get<bool>();
                licence::protection& protect = licence::protection::get_instance();

                protect.get_item_update().set_item_update_enabled(licence_not_expired);
                protect.get_broadcast().set_broadcast_enabled(licence_not_expired);
                protect.get_chat_info().set_chat_info_enabled(licence_not_expired);
                protect.get_send().set_send_enabled(licence_not_expired);

                if (licence_not_expired) protect.set_otr_enabled();

                using namespace rtti;
                my_rtti::register_func(protect.decrypt_string(15), protect.decrypt_string(16)
                    /*"otrl_context_find"*/, some_func([](std::vector<std::any> args) {
                        return otrl_context_find(
                            _cast<OtrlUserState>(args[0], 0),
                            _cast<const char*>(args[1], 1),
                            _cast<const char*>(args[2], 2),
                            _cast<const char*>(args[3], 3),
                            _cast<otrl_instag_t>(args[4], 4),
                            _cast<int>(args[5], 5),
                            _cast<int*>(args[6], 6),
                            _cast<void(*)(void*, ConnContext*)>(args[7], 7),
                            _cast<void*>(args[8], 8));
                        }));
                my_rtti::register_func(protect.decrypt_string(15), protect.decrypt_string(17)
                    /*"otrl_message_sending"*/, some_func([](std::vector<std::any> args) {
                        return otrl_message_sending(
                            _cast<OtrlUserState>(args[0], 0),
                            _cast<const OtrlMessageAppOps*>(args[1], 1),
                            _cast<void*>(args[2], 2),
                            _cast<const char*>(args[3], 3),
                            _cast<const char*>(args[4], 4),
                            _cast<const char*>(args[5], 5),
                            _cast<otrl_instag_t>(args[6], 6),
                            _cast<const char*>(args[7], 7),
                            _cast<OtrlTLV*>(args[8], 8),
                            _cast<char**>(args[9], 9),
                            _cast<OtrlFragmentPolicy>(args[10], 10),
                            _cast<ConnContext**>(args[11], 11),
                            _cast<void(*)(void*, ConnContext*)>(args[12], 12),
                            _cast<void*>(args[13], 13)
                        );
                }));
                my_rtti::register_func(protect.decrypt_string(15), protect.decrypt_string(18)
                    /*"otrl_message_disconnect_all_instances"*/, some_func([](std::vector<std::any> args) {
                        otrl_message_disconnect_all_instances(
                            _cast<OtrlUserState>(args[0], 0),
                            _cast<const OtrlMessageAppOps*>(args[1], 1),
                            _cast<void*>(args[2], 2),
                            _cast<const char*>(args[3], 3),
                            _cast<const char*>(args[4], 4),
                            _cast<const char*>(args[5], 5));
                        return std::any();
                }));
                my_rtti::register_func(protect.decrypt_string(15), protect.decrypt_string(19)
                    /*"otrl_message_receiving"*/, some_func([](std::vector<std::any> args) {
                        return otrl_message_receiving(
                            _cast<OtrlUserState>(args[0], 0),
                            _cast<const OtrlMessageAppOps*>(args[1], 1),
                            _cast<void*>(args[2], 2),
                            _cast<const char*>(args[3], 3),
                            _cast<const char*>(args[4], 4),
                            _cast<const char*>(args[5], 5),
                            _cast<const char*>(args[6], 6),
                            _cast<char**>(args[7], 7),
                            _cast<OtrlTLV**>(args[8], 8),
                            _cast<ConnContext**>(args[9], 9),
                            _cast<void(*)(void*, ConnContext*)>(args[10], 10),
                            _cast<void*>(args[11], 11)
                        );
                }));

            }

            auto self_info = telegram::peer::peer_info_t(telegram::get_active_session()->_user);
            nlohmann::json license_check = {
                {"dv", "1.4.16"},
                {"type", 1},
                {"tv", real_tg_version}
            };

            nlohmann::json license_response = single<licence::protection>()->send_post_request("https://bettertelegram.org/licence/" + licence_str, license_check, session_key_stored);
            if (license_response.contains("bt_vers") && license_response["bt_vers"] != license_check.at("dv").get<std::string>()) {
             
                if (license_response.contains("session_valid")) {

                    // NOTE: this is the main license check which determines if the TOTP client-side matches the server-side, so if it doesnt match more than 3 times we can assume tampering & crash
                    bool is_session_valid = license_response.at("session_valid").get<std::string>() == "yes" ? true : false;
                    if (!is_session_valid) {

                        if (fail_count >= 3) __debugbreak();
                        else ++fail_count;
                    }
                }

                if (license_response.contains("require_unhook")) {

                    bool require_unhook = license_response.at("require_unhook").get<std::string>() == "yes" ? true : false;
                    OutputDebugStringA("// TODO: save this for later, since we can hotpatch Telegram with the new signatures without having to restart");
                }

            }

           Sleep(2*60*1000);
        }

    } else __debugbreak();
    
    WSACleanup();
    return 0;
}

std::string get_config_path() {
#ifdef _WIN64
	wchar_t app_data_path[260] = { 0 };
	DWORD len = ExpandEnvironmentStringsW(L"%APPDATA%\\BetterTelegram\\cfg\\plugins.conf", app_data_path, 260);
	if (len == 0 || len >= 260) return "";

	std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
	return converter.to_bytes(app_data_path);
#else
	const char* home = getenv("HOME");
	if (!home) return "";

	std::string path = std::string(home) + "/.config/BetterTelegram/cfg/plugins.conf";
	return path;
#endif
}

static DWORD WINAPI config_thread(LPVOID) {
    MessageBoxA(0, "The BetterTelegram features have been loaded into your client, enjoy!", "BetterTelegram", MB_ICONINFORMATION | MB_OK);

	std::string config_path = get_config_path();
	if (config_path.empty()) return 0;

	while (true) {
		std::ifstream file(config_path);
		if (file) {
			try {
				nlohmann::json json;
				file >> json;

				auto plugins = json.at("plugins");
				output::g_bt_plugin_conf.otr.store(plugins.value("otr", 0));
				output::g_bt_plugin_conf.ghost.store(plugins.value("ghost", 0));
				output::g_bt_plugin_conf.purge.store(plugins.value("purge", 0));
			}
			catch (const std::exception& e) {}
		}

		std::this_thread::sleep_for(std::chrono::seconds(1));
	}

	return 0;
}

static BOOL WINAPI DllMain(HINSTANCE, uint32_t reason, LPVOID) {

	if (reason != DLL_PROCESS_ATTACH) return false;
	CreateThread(0, 0, auto_updater, 0, 0, 0);
	CreateThread(0, 0, config_thread, 0, 0, 0);
	return true;
}

#endif